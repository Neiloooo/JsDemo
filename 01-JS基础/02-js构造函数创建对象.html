<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>构造函数创建对象</title>
</head>
<body>
<script type="text/html">
    //1.字面量的方式创建对象(缺点:复用性极差)
    var p1 = {
        name: "张三",
        run: function () {
            console.log(this.name + "跑")
        }
    };
    console.log(p1.name);
    p1.run();

    //2.内置构造函数的方式创建对象(可扩展行极差)
    var p2 = new Object();
    p2.name = "李四";
    p2.run = function () {
        console.log(this.name + "跑");
    }

    //3.简单的工厂模式创建对象(问 题:无法判断类型)

    //4.自定义函数:
    // ①函数的首字母大写(用于区别构造函数与普通函数)
    // ②创建对象的过程由new关键字实现
    // ③在构造函数内部会自动的创建新对象,并赋值给this指针
    // ④自动返回创建出来的对象

    //1.构造函数
    function Person() {
        //1.this-->新对象(函数内部自动执行)
        // var this  = new Objcet(); //1.自动创建一个空对象,把对象的地址给了this


        //2.this 给空对象绑定属性和行为
        this.name=name;
        let age;
        let sex;

        //3.函数自动返回this
        //return this;
    }

    const p = new Person(); // 通过new关键字来创建对象

</script>
<script type="text/html">
    //1.如果不写,直接返回默认创建的新对象
    //2.如果返回this,同样直接返回默认创建的新对象
    //3.如果返回基本的数据类型,同样直接返回默认创建的新对象
    //4.如果返回的是对象,则是返回我们创建的对象,而不是默认的对象
    function Pseron(name,age) {
        this.name=name;
        this.age=age;
    }
    const p = new Pseron("zsl", 18);
    console.log(p)



</script>
<script>
    //构造函数的方式创建对象
    function Dog(name,age,dogFriends) {
        //对象的属性
        this.name=name;
        this.age=age;
        this.dogFriends = dogFriends;

        //对象的行为
        this.eat=function (someThing) {
            console.log(this.name+"吃"+someThing)
        };
        this.run=function (someWhere) {
            console.log(this.name+"跑"+someWhere)
        };

        //产生对象
        const smallDog = new Dog("小王八", 1);
        console.log(smallDog.name,smallDog.age)
    }
</script>
</body>
</html>